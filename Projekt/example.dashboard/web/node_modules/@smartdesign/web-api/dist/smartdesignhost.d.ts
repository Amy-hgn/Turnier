// Generated by dts-bundle-generator v8.0.1

export declare class Communicator<REMOTE = any> {
	private targetOrigin;
	private target;
	private source;
	private defaultTimeout;
	constructor(targetOrigin: string, target: () => IEndpoint, source: () => IEndpoint, defaultTimeout?: number);
	private parseJSON;
	private unwrapMessage;
	private wrapMessage;
	expose(object: any, action: string): () => void;
	invoke<METHOD extends StringKeyOf<REMOTE> = any, ARGS extends ArgumentTypes<REMOTE[METHOD]> = ArgumentTypes<REMOTE[METHOD]>, RETURNTYPE extends Awaited<ReturnType<REMOTE[METHOD]>> = Awaited<ReturnType<REMOTE[METHOD]>>>(method: METHOD, ...args: ARGS): Promise<RETURNTYPE>;
	invokeRelaxed<METHOD extends StringKeyOf<REMOTE> = any, ARGS extends ArgumentTypes<REMOTE[METHOD]> = ArgumentTypes<REMOTE[METHOD]>, RETURNTYPE extends Awaited<ReturnType<REMOTE[METHOD]>> = Awaited<ReturnType<REMOTE[METHOD]>>>(method: METHOD, ...args: ARGS): Promise<RETURNTYPE>;
	private postInternal;
	post<METHOD extends StringKeyOf<REMOTE> = any, ARGS extends ArgumentTypes<REMOTE[METHOD]> = ArgumentTypes<REMOTE[METHOD]>>(method: METHOD, ...args: ARGS): void;
}
export declare const createCommunicator: <REMOTE = any>(appDomain: string, target: () => IEndpoint, source?: () => IEndpoint, timeout?: number) => Communicator<REMOTE>;
/**
 * Creates a tunnel for cross tab communication.
 * The resulting iframe should be appended to the html document, and then it can be used as a parameter to [[connect]].
 * @param {string} host Url of the SmartDesign instance. e.g. https://mycompany.com/smartdesign or http://login.smartwe.de/SmartWe/
 * @param {VoidFunction} readyCallback Callback to execute after the tunnel is established
 * @return {HTMLIFrameElement} frame element to be used for the tunneling
 */
export declare const createTunnel: (host: string, readyCallback: () => void) => HTMLIFrameElement;
export declare const expose: (appDomain: string, obj: any, target: () => IEndpoint, source?: () => IEndpoint, timeout?: number) => (() => void);
export declare const invokeMethod: (domain: string, target: () => IEndpoint, source: () => IEndpoint, method: string, parameters?: any[]) => Promise<any>;
export declare namespace SmartDesign {
	type IAPI<T = any> = IHostAPI<T>;
}
/**
 * Represents an area within to the client window, can usually be retrieved by calling getBoundingClientRect()
 */
export interface Area {
	x: number;
	y: number;
	width: number;
	height: number;
}
/**
 * Represents a position relative to the client window, can usually be retrieved from standard event properties, e.g. event.clientX, event.clientY
 */
export interface Coordinate {
	x: number;
	y: number;
}
export interface FieldInfo extends FieldMetadata {
	/**
	 * Contains the description of a potential validation failure
	 */
	validationMessage: string;
	/**
	 * Contains the validation state set by the last value change
	 */
	validationState: "valid" | "warning" | "error";
}
export interface FieldMetadata {
	/**
	 * Contains the name of the object type for which this field belongs to
	 */
	readonly objectTypeName: string;
	/**
	 * Contains the name for this field
	 */
	readonly fieldName: string;
	/**
	 * Contains the label for this field
	 */
	readonly label: string;
	/**
	 * True if the current user has read access on this field.
	 */
	readonly readable: boolean;
	/**
	 * True if the user has the privilege to update values for this field.
	 */
	readonly updateable: boolean;
	/**
	 * True for mandatory fields.
	 */
	readonly mandatory: boolean;
	/**
	 * True for recommended fields.
	 */
	readonly recommended: boolean;
	/**
	 * True for hidden fields.
	 */
	readonly hidden: boolean;
	/**
	 * True for custom fields.
	 */
	readonly custom: boolean;
}
export interface FieldWithPossibleValue<T> extends FieldInfo {
	/**
	 * The list of possible values for the current field, if it provides any.
	 */
	possibleValues?: T[];
}
/**
 * Contains the aggregation result for a single group.
 */
export interface GroupResult<GROUP, VALUE> {
	/**
	 * The group value is `undefined` for the group of records without a value in the grouped column.
	 */
	readonly groupValue: GROUP | undefined;
	/**
	 * The aggregated value for this group.
	 */
	readonly aggregatedValue: VALUE;
}
/**
 * Contains information about a single command
 */
export interface ICommand extends ICommandRepresentation {
	/**
	 * The callback to be executed
	 */
	callback: VoidFunction;
}
/**
 * Contains representation specific information about a single command
 */
export interface ICommandRepresentation {
	/**
	 * The id of the command
	 * @type {string}
	 */
	id: string;
	/**
	 * A flag which determines whether the command is enabled.
	 * @type {boolean}
	 */
	enabled: boolean;
	/**
	 * The qualified name of the icon to be shown.
	 * The icons are loaded from the icons folder (next to the app manifest).
	 * Platform icons can be used with the `platform:` qualifier e.g. `platform:new`;
	 *
	 * @type {string}
	 */
	icon: string;
	/**
	 * The label to be shown
	 * @type {string}
	 */
	label: string;
	/**
	 * Alternative label in case this command is contributed to a command group
	 * @type {string}
	 */
	inGroupLabel?: string;
	/**
	 * The id of the parent group
	 * @type {string}
	 */
	pointId?: string;
	/**
	 * The description to be used (as a tooltip)
	 * @type {string}
	 */
	description: string;
}
export interface IDataObjectContextItemMetadata {
	type: "DataObject";
	/**
	 * The data record type
	 */
	objectTypeName: string;
	/**
	 * The id of the data record
	 */
	id: string;
	/**
	 * The name of the context item as defined in the form definition
	 */
	name: string;
}
export interface IDialogButtonDefinition {
	/**
	 * The ID that is used to identify the pressed button when processing the result.
	 *
	 * Note that it's not displayed to the user (in case the caption is present).
	 */
	id: DialogButtonId;
	/**
	 * The caption that will be shown to the user on the UI.
	 *
	 * Note that for default buttons (buttons with ID "OK", "YES", "NO" or "CANCEL") this
	 * is automatically set with a translated value if absent.
	 */
	caption?: string;
	/**
	 * Indicates whether the button defines the primary action and should be visualized differenly.
	 */
	primary?: boolean;
}
export interface IDialogOptions {
	/**
	 * The title for the dialog window.
	 */
	title: string;
	/**
	 * The message that will be shown in the main area of the dialog window.
	 */
	message: string;
	/**
	 * The buttons that will be shown for user interaction.
	 *
	 * It can be a preset ("OK" | "OK_CANCEL" | "YES_NO" | "YES_NO_CANCEL") or a list of
	 * DialogButtonDefinition that allows custom buttons to be shown.
	 */
	buttons?: DialogButtonPreset | IDialogButtonDefinition[];
	/**
	 * Defines the style of the dialog that usually shows the user how severe the shown information is.
	 */
	style?: DialogStyle;
}
export interface IEndpoint {
	postMessage(message: any, targetOrigin: string, transfer?: any[]): void;
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
}
/**
 * Represents a group
 */
export interface IGroup extends ICommandRepresentation {
	group?: true;
}
export interface IHostAPI<T = any> {
	navigate(intent: string, options?: INavigationOptions): void;
	navigateWithRecord(objectType: string, gguid: string, intent?: string, options?: IRecordNavigationOptions): void;
	navigateWithRecords(objectType: string, selection: INavigationSelection, intent?: string, options?: INavigationOptions): void;
	navigateToDossier(source: ISingleSelection, selection?: ISingleSelection, intent?: string, navigateToDossier?: string[], options?: INavigationOptions): void;
	reload(): void;
	navigateHome(): void;
	navigateBack(): void;
	urlChanged(url: string): void;
	setBackwardNavigationMode(mode: BackNavigationMode): Promise<void>;
	initApp(origin?: string): InitParameters<T> | Promise<InitParameters<T>>;
	requestResize(width: number, height: number): void;
	provideCaption(caption: string): void;
	contributeCommand(command: IGroup | ICommand): void;
	revokeCommand(id: string): void;
	openSearch(objectType: string, query?: SearchQuery): Promise<OpenSearchResponse>;
	openDialog(dialogOptions: IDialogOptions): Promise<IOpenDialogResponse>;
	updateState(state: T): Promise<void>;
	getAllAppSettings(appId: string, scope: AppSettingsScope): Promise<Record<string, unknown>>;
	setAllAppSettings(appId: string, scope: AppSettingsScope, mode: AppSettingsSetMode, settings: Record<string, unknown>): Promise<void>;
	getAppSettings(appId: string, scope: AppSettingsScope, propertyName: string): Promise<unknown>;
	deleteAppSettings(appId: string, scope: AppSettingsScope, propertyName: string): Promise<void>;
	showLoadingIndicator(options?: LoadingIndicatorOptions): void;
	hideLoadingIndicator(): void;
	openFlyoutMenu(items: IFlyoutMenuItem[], positionOrArea: Coordinate | Area): Promise<IMenuItem | null>;
	openRadialMenu(items: IRadialMenuItem[], radialMenuOptions: RadialMenuOptions, position: Coordinate): Promise<IRadialMenuItem | null>;
	massDataOperationLoad(contextItemName: string, fieldNames: string[], from: number, pageSize: number, where?: string): Promise<IMassDataResponse<unknown>>;
	massDataOperationCount(contextItemName: string): Promise<number>;
	massDataOperationSum(contextItemName: string, fieldName: string): Promise<number | string | undefined>;
	massDataOperationMin(contextItemName: string, fieldName: string): Promise<number | string | undefined>;
	massDataOperationMax(contextItemName: string, fieldName: string): Promise<number | string | undefined>;
	massDataOperationAverage(contextItemName: string, fieldName: string): Promise<number | string | undefined>;
	dependentDataObjectsOperationLoad(contextItemName: string, fieldNames: string[]): Promise<IMassDataResponse<unknown>>;
	registerContextItemInvalidateInterest(contextItemName: string): Promise<void>;
	unregisterContextItemInvalidateInterest(contextItemName: string): Promise<void>;
	aggregationOperationGet(contextItemName: string): Promise<GroupResult<unknown, unknown>[]> | Promise<unknown>;
	fieldAggregationGetMetadata(propertyName: string): Promise<FieldMetadata>;
	scriptedAggregationGet(propertyName: string): Promise<ScriptedGroupedAggregationResult<any> | ScriptedUngroupedAggregationResult<any>>;
	getField(contextItemName: string, fieldName: string): Promise<Field<any>>;
	getFields(contextItemName: string, ...fieldNames: string[]): Promise<Record<string, Field<any>>>;
	updateField(contextItemName: string, field: Field<any>): Promise<void>;
	updateFields(contextItemName: string, changes: Record<string, Field<any>>): Promise<void>;
	getMetadata(objectTypeName: string): Promise<Record<string, FieldMetadata>>;
	registerFieldInterest(contextItemName: string, fieldName: string): Promise<void>;
	unregisterFieldInterest(contextItemName: string, fieldName: string): Promise<void>;
}
export interface IMassDataObjectContextItemMetadata {
	/**
	 * The type of the context item
	 */
	type: "MassData";
	/**
	 * The data record type
	 */
	objectTypeName: string;
	/**
	 * The name of the context item as defined in the form definition
	 */
	name: string;
}
/**
 * Contains the result of a mass data load request
 */
export interface IMassDataResponse<T> {
	/**
	 * The resulting rows
	 */
	rows: T[];
	/**
	 * Metadata for the requested columns
	 */
	columns: {
		[K in keyof T]: FieldMetadata;
	};
}
/**
 * Contains information about a single menu item
 */
export interface IMenuItem {
	/**
	 * The id of the menu item
	 * @type {string}
	 */
	id: string;
	/**
	 * A flag which determines whether the menu item is enabled.
	 * @type {boolean}
	 */
	enabled: boolean;
	/**
	 * The qualified name of the icon to be shown.
	 * The icons are loaded from the icons folder (next to the app manifest).
	 * Platform icons can be used with the `platform:` qualifier e.g. `platform:new`;
	 *
	 * @type {string}
	 */
	icon: string;
	/**
	 * The caption to be shown
	 * @type {string}
	 */
	caption: string;
	/**
	 * The description to be used (as a tooltip)
	 * @type {string}
	 */
	description: string;
}
/**
 * Represents a horizontal separator between list items
 */
export interface IMenuItemSeparator {
	separator: true;
}
/**
 * Additional parameters for the navigation.
 */
export interface INavigationOptions {
	/**
	 * Whether the new page(s) openned on a new tab or not
	 * @type {boolean}
	 */
	newTab: boolean;
}
export interface INavigationSelection {
	gguids: string[];
	selectedGuid: string;
}
export interface IOpenDialogResponse {
	/**
	 * The ID of the button that was pressed.
	 */
	buttonId: DialogButtonId;
}
/**
 * Contains information about a single radial menu item
 */
export interface IRadialMenuItem extends IMenuItem {
	/**
	 * The category to be used for the slice
	 */
	category: RadialMenuCategory;
}
export interface IRecordNavigationOptions extends INavigationOptions {
	/**
	 * Whether the edit mode should be opened or not.
	 * @type {boolean}
	 */
	editMode: boolean;
}
export interface ISingleSelection {
	objectType: string;
	gguid: string;
}
/**
 * Contains configuration parameters and information about the enabled
 * capabilities of the integrated html app.
 */
export interface InitParameters<STATE> {
	/**
	 * Unique identifier of the current instance
	 */
	token: string;
	/**
	 * The base url for rest operations
	 */
	baseUrl: string;
	/**
	 * A flag which indicates whether the rest operations are enabled
	 */
	restEnabled: boolean;
	/**
	 * An object containing information about the user locale
	 */
	locale: LocaleInformation;
	/**
	 * List of possible navigation intents
	 */
	intents: string[];
	/**
	 * List of supported back navigation modes
	 */
	backNavigationModes: BackNavigationMode[];
	/**
	 * A flag which indicates whether the Dialog API is supported.
	 */
	openDialogSupported?: boolean;
	/**
	 * A flag which indicates whether the openSearch method of the api is supported.
	 */
	openSearchSupported?: boolean;
	/**
	 * A flag which indicates whether the primaryDataObjectContextItem method of the api is supported.
	 */
	stateUpdateSupported?: boolean;
	/**
	 * A flag which indicates whether the primaryDataObjectContextItem method of the api is supported.
	 */
	stateOnChangeSupported?: boolean;
	/**
	 * A flag which indicates whether showing the loading indicator is supported.
	 */
	loadingIndicatorShowSupported?: boolean;
	/**
	 * A flag which indicates whether user interaction blocking on the current app/widget is supported.
	 */
	loadingIndicatorBlockSupported?: boolean;
	/**
	 * A flag which indicates whether user interaction blocking on the host is supported.
	 */
	loadingIndicatorBlockHostSupported?: boolean;
	/**
	 * A flag which indicates whether reloading the current page is supported
	 */
	reloadSupported?: boolean;
	/**
	 * A flag which indicates whether opening a flyout menu is supported
	 */
	flyoutMenuSupported?: boolean;
	/**
	 * A flag which indicates whether opening a radial menu is supported
	 */
	radialMenuSupported?: boolean;
	/**
	 * A flag which indicates whether commands are supported
	 */
	commandsSupported?: boolean;
	/**
	 * A flag which indicates whether accessing the app settings is supported
	 */
	appSettingsSupported?: boolean;
	/**
	 * A flag which indicates whether accessing the primary data object context item is suppoorted
	 */
	primaryDataObjectAccessorSupported?: boolean;
	/**
	 * A flag which indicates whether accessing the primary mass data context item is suppoorted
	 */
	primaryMassDataAccessorSupported?: boolean;
	/**
	 * A flag which indicates whether the Devices API is supported.
	 */
	devicesSupported?: boolean;
	/**
	 * The primary data object context item
	 */
	primaryDataObject?: IDataObjectContextItemMetadata;
	/**
	 * The primary mass data object context item
	 */
	primaryMassData?: IMassDataObjectContextItemMetadata;
	/**
	 * A flat JSON structure containing design token overrides from the host environment
	 */
	designTokens?: Record<string, string | number>;
	/**
	 * The initial state
	 */
	state?: STATE;
}
export interface LoadingIndicatorOptions {
	/**
	 * The time in milliseconds after the loading indicator will be stopped automatically.
	 * The default timeout is 30 seconds, the longest is 1 minute.
	 */
	timeoutInMs?: number;
	/**
	 * Indicates whether user interactions on the host should be blocked while the
	 * loading indicator is on.
	 */
	blockHost?: boolean;
	/**
	 * Indicates whether user interactions on the current app/widget should be blocked while the
	 * loading indicator is on.
	 *
	 * Note that although some interaction may be blocked, this should not be considered as a
	 * security feature, additional steps may be needed for example to disable keyboard actions.
	 */
	block?: boolean;
}
export interface LocaleInformation {
	/**
	 * ISO code of the user locale
	 */
	language: string;
}
export interface MultiValueField<T> extends FieldWithPossibleValue<T> {
	/**
	 * Current value of the field
	 */
	value: T[];
}
/**
 * Contains information about the search selection result
 */
export interface OpenSearchResponse {
	/**
	 * Array of gguids of the selected objects
	 */
	objectGguids: string[];
}
/**
 * Contains representation related options for the radial menu
 */
export interface RadialMenuOptions {
	centerIcon: string;
	centerColor: string;
}
/**
 * Configuration class for the search queries
 */
export interface SearchQuery {
	/**
	 * Where clause for the query, e.g. `WORKINGPERCENT > 0 AND PRIORITY = 'A'`
	 */
	where?: string;
	/**
	 * A flag which indicates whether the search results should be shown without a search text
	 */
	showResultsWithEmptySearchTerm?: boolean;
	/**
	 * Order by clause for the query, e.g. `KEYWORD ASC, UPDATETIMESTAMP DESC`
	 */
	orderBy?: string;
}
export interface SingleValueField<T> extends FieldWithPossibleValue<T> {
	/**
	 * Current value of the field
	 */
	value: T;
}
export interface StringTreeSuggestField extends FieldInfo {
	/**
	 * Current value of the field
	 */
	value: StringTreeSuggestPath[];
	/**
	 * Root node of the tree of possible values
	 */
	root: StringTreeSuggestNode;
}
export interface StringTreeSuggestNode {
	name: string;
	path: StringTreeSuggestPath;
	selectable: boolean;
	selectionType: SelectionType;
	childSelectionType: SelectionType;
	children: StringTreeSuggestNode[];
}
export type AppSettingsScope = "GLOBAL" | "USER" | "EFFECTIVE";
export type AppSettingsSetMode = "OVERWRITE" | "EXTEND";
export type ArgumentTypes<F> = F extends (...args: infer A) => any ? A : never;
export type Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;
/**
 * The back navigation mode determines how the navigation stack is threated.
 *
 * NONE
 * The host can navigate back without navigating back inside
 * the web app. This is the default.
 *
 * LINEAR
 * The visited urls are stored in a stack, upon back navigation in the host,
 * the web app url is restored to the previous value.
 *
 * COMPRESSED
 * Similar to the LINEAR mode, with the exception that if a url is visited
 * again, the navigation history of the web app is dropped until that point.
 */
export type BackNavigationMode = "NONE" | "LINEAR" | "COMPRESSED";
export type DialogButtonId = "OK" | "YES" | "NO" | "CANCEL" | (string & {
	x?: never;
});
export type DialogButtonPreset = "OK" | "OK_CANCEL" | "YES_NO" | "YES_NO_CANCEL";
export type DialogStyle = "INFO" | "WARNING" | "ERROR";
export type Field<T> = SingleValueField<T> | MultiValueField<T> | StringTreeSuggestField;
/**
 * Contains information about a single flyout menu item
 */
export type IFlyoutMenuItem = IMenuItem | IMenuItemSeparator;
/**
 * The category a radial menu item belongs to
 */
export type RadialMenuCategory = "standard" | "communication" | "creation" | "information";
export type ReturnType<T> = T extends (...args: any) => infer R ? R : any;
/**
 * Represents a single value within an aggregation.
 */
export type ScriptedAggregatedValue<RAW_VALUE extends ScriptedAggregationRawValueTypes> = {
	/**
	 * Raw value of the aggregation result.
	 */
	raw?: RAW_VALUE;
	/**
	 * Numeric value, e.g., used for drawing charts.
	 */
	numeric?: number | string;
	/**
	 * Display value, e.g., for the label of bars, tooltips, ...
	 * If not specified, the widget is free to generate the display value
	 * from the raw/numeric value and formatting options.
	 */
	display?: string;
};
export type ScriptedAggregationRawValueTypes = number | string | boolean | Date | undefined;
/**
 * Represents the formatting options for a given aggregation result.
 */
export type ScriptedFormattingOptions = {
	/**
	 * The number of decimal places to display for numeric values.
	 */
	decimalPlaces?: number;
	/**
	 * Additional formatting options for date values
	 */
	dateFormat?: Partial<{
		/**
		 * Include the date portion (year, month, day) in the output.
		 *
		 * Default: true
		 */
		date: boolean;
		/**
		 * Include the time portion (hours, minutes, and optionally seconds) in the output.
		 *
		 * Default: true
		 */
		time: boolean;
		/**
		 * If time is included, seconds will be displayed in the output as well.
		 *
		 * Default: false
		 */
		seconds: boolean;
		/**
		 * If the date is yesterday, today, or tomorrow, the date will be formatted textually
		 * as "Yesterday", "Today", or "Tomorrow", in the respective user language.
		 *
		 * Default: true
		 */
		preferRelativeDay: boolean;
	}>;
	/**
	 * The unit of the aggregated value.
	 */
	unit?: string;
};
/**
 * Represents a single group within a grouped aggregation result.
 */
export type ScriptedGroupResult<RAW_VALUE extends ScriptedAggregationRawValueTypes> = {
	/**
	 * Label of the group to be displayed.
	 */
	group?: string;
	/**
	 * Group value
	 */
	value: ScriptedAggregatedValue<RAW_VALUE>;
	/**
	 * Group color
	 */
	color?: string;
};
/**
 * Represents a grouped aggregation result.
 */
export type ScriptedGroupedAggregationResult<RAW_VALUE extends ScriptedAggregationRawValueTypes> = {
	type: "grouped";
	groups: ScriptedGroupResult<RAW_VALUE>[];
	formatting?: ScriptedFormattingOptions;
};
/**
 * Represents an ungrouped aggregation result.
 */
export type ScriptedUngroupedAggregationResult<RAW_VALUE extends ScriptedAggregationRawValueTypes> = {
	type: "ungrouped";
	value: ScriptedAggregatedValue<RAW_VALUE>;
	formatting?: ScriptedFormattingOptions;
};
export type SelectionType = "single" | "multi";
export type StringKeyOf<T> = Extract<keyof T, string>;
export type StringTreeSuggestPath = string[];

export {};
