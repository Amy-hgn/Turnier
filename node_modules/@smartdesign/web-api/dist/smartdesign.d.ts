// Generated by dts-bundle-generator v8.0.1

declare const ACTION_MENU_ID = "actionMenu";
declare const VIEW_MENU_ID = "viewMenu";
/**
 * Constant for easier separator usage
 */
export declare const MenuItemSeparator: IMenuItemSeparator;
/**
 * Connects to the SmartDesign api.
 * @param targetOrigin The origin of the SmartDesign host, for hosted apps this can be omitted
 * @param target Accessor method to the window object of the SmartDesign host, usually ()=> window.parent
 * @param source Accessor method to the window object of the SmartDesign app frame, usually ()=> window
 * @param timeout Timeout for the sent messages
 */
export declare const connect: <T extends ICustomState>(targetOrigin?: string, target?: () => IEndpoint, source?: () => IEndpoint, timeout?: number) => IPromise<SmartDesign.IAPI<T>>;
/**
 * Creates a tunnel for cross tab communication.
 * The resulting iframe should be appended to the html document, and then it can be used as a parameter to [[connect]].
 * @param host Url of the SmartDesign instance. e.g. https://mycompany.com/smartdesign or http://login.smartwe.de/SmartWe/
 * @param readyCallback Callback to execute after the tunnel is established
 */
export declare const createTunnel: (host: string, readyCallback: () => void) => HTMLIFrameElement;
export declare const isAggregation: (object: unknown) => object is IFieldAggregation;
export declare const isContextItem: (object: unknown) => object is IContextItem;
export declare const isFieldAggregation: (object: unknown) => object is IFieldAggregation;
export declare const isMultiValueField: <T>(field: Field<T>) => field is MultiValueField<T>;
export declare const isScriptedAggregation: (object: unknown) => object is IScriptedAggregation;
export declare const isSingleValueField: <T>(field: Field<T>) => field is SingleValueField<T>;
export declare const isStringTreeSuggestField: <T>(field: Field<T>) => field is StringTreeSuggestField;
/**
 * Main entry point for the html app integration of SmartDesign
 * Amongst other things, it provides access to the rest api,
 * can trigger navigations in the surrounding SmartDesign application etc.
 */
export declare namespace SmartDesign {
	interface IAPI<T extends ICustomState = ICustomState> {
		/**
		 * Provides access to the Navigation api.
		 */
		Navigation: INavigation;
		/**
		 * Provides access to the Dialog api.
		 */
		Dialog: IDialogApi;
		/**
		 * Provides access to the Search api.
		 */
		Search: ISearch;
		/**
		 * Provides access to the Settings api.
		 */
		Settings?: ISettings;
		/**
		 * Provides acess to the activation service.
		 */
		ActivationService: IActivationService;
		/**
		 * Provides access to context items
		 */
		Context: IContext;
		/**
		 * Provides access to the Overlay api
		 */
		Overlay: IOverlay;
		/**
		 * Provides access to commands
		 */
		Command: ICommandService;
		/**
		 * Provides access to the application-wise loading indicator.
		 */
		LoadingIndicator: ILoadingIndicator;
		/**
		 * Provides access to the State api
		 */
		State: IState<T>;
		/**
		 * Provides access to platform specific input devices
		 */
		InputDevice: IInputDeviceService;
		/**
		 * Inherits design tokens from the surrounding application and applies them as css variables by default.
		 * The inherited design tokens are returned.
		 */
		inheritDesignTokens?(applyAsCssVariables?: boolean): Record<string, string | number>;
		/**
		 * An object containing information about the user locale
		 */
		readonly locale?: LocaleInformation;
		/**
		 * Sets the caption of the surrounding container e.g. in case of web apps the title of the page.
		 */
		provideCaption?: (caption: string) => Promise<void>;
		/**
		 * Provides access to the REST API and automatically appends the necessary request headers.
		 * Wraps the fetch api, for further information see: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
		 * Returns a rejected promise in case when the rest api is disabled.
		 */
		fetch(input: string, init?: RequestInit): Promise<Response>;
		/**
		 * Enables automatic tracking of url changes in order to save the state of the app properly.
		 */
		trackUrlChanges(): void;
		/**
		 * Signals a change in the required width and height of the embedded app / widget.
		 * The values are interpreted as pixels.
		 * In case when the content must adapt to the container size, use any negative number.
		 */
		requestResize(width: number, height: number): void;
		/**
		 * A flag which indicates whether the rest operations are enabled
		 */
		readonly restEnabled: boolean;
	}
	/**
	 * Entry point for triggering a navigation in the surrounding SmartDesign application
	 */
	interface INavigation {
		/**
		 * Returns a flag which indicates whether the given navigation mode is supported.
		 * @param mode BackNavigationMode to be checked
		 */
		isBackwardNavigationModeSupported(mode: BackNavigationMode): boolean;
		/**
		 * Sets the backward navigation mode which determines how the navigation stack is treated.
		 * Returns a rejected Promise if the navigation mode is not supported.
		 * @param mode BackNavigationMode to apply
		 */
		setBackwardNavigationMode(mode: BackNavigationMode): Promise<void>;
		/**
		 * Triggers a navigation with the given navigation intent without any context information.
		 * Additional navigation parameters can be configured by using the returned NavigationBuilder.
		 * @see {@link INavigationBuilder}
		 * @param {string} intent
		 * @returns {INavigationBuilder}
		 * @memberof Navigation
		 */
		navigate(intent?: string): INavigationBuilder;
		/**
		 * Triggers a navigation to the given dataobject set by returned navigation builder.
		 * @see {@link INavigationWithRecordBuilder}
		 * @returns {INavigationWithRecordBuilder}
		 * @memberof Navigation
		 */
		navigateWithRecord(): INavigationWithRecordBuilder;
		/**
		 * Triggers a navigation to the given dataobject, by default it uses the
		 * 'open record with list' navigation intent. Additional navigation parameters
		 * can be configured by using the returned NavigationWithRecordBuilder.
		 * @see {@link INavigationWithRecordBuilder}
		 * @param {string} objectType
		 * @param {String} gguid
		 * @param {string} [intent]
		 * @returns {INavigationWithRecordBuilder}
		 * @memberof Navigation
		 */
		navigateWithRecord(objectType: string, gguid: string, intent?: string): INavigationWithRecordBuilder;
		/**
		 * Triggers a navigation with the selected data objects. Additional navigation parameters
		 * can be configured by using the returned NavigationWithRecordsBuilder.
		 * @see {@link INavigationWithRecordsBuilder}
		 * @returns {INavigationWithRecordsBuilder}
		 * @memberof Navigation
		 */
		navigateWithRecords(): INavigationWithRecordsBuilder;
		/**
		 * Triggers a navigation with the selected data objects. Additional navigation parameters
		 * can be configured by using the returned NavigationWithRecordsBuilder.
		 * @see {@link INavigationWithRecordsBuilder}
		 * @param {string} objectType type of the data objects
		 * @param {string[]} gguids array of the data objects ids
		 * @param {string} [selectedGguid] selected data object id, if there is any
		 * @param {string} [intent] navigation intent
		 * @returns {INavigationWithRecordsBuilder}
		 * @memberof Navigation
		 */
		navigateWithRecords(objectType: string, gguids: string[], selectedGguid?: string, intent?: string): INavigationWithRecordsBuilder;
		/**
		 * Triggers a navigation with dossier items of the source object. Additional navigation
		 * parameters can be configured by using the returned NavigationWithDossierBuilder.
		 * @see {@link INavigationWithDossierBuilder}
		 * @returns {INavigationWithDossierBuilder}
		 * @memberof Navigation
		 */
		navigateToDossier(): INavigationWithDossierBuilder;
		/**
		 * Triggers a navigation with dossier items of the source object. Additional navigation
		 * parameters can be configured by using the returned NavigationWithDossierBuilder.
		 * @see {@link INavigationWithDossierBuilder}
		 * @param {string} sourceObjectType type of the source data object
		 * @param {string} sourceGguid id of the source data object
		 * @param {string} [intent] Navigation intent
		 * @returns {INavigationWithDossierBuilder}
		 * @memberof Navigation
		 */
		navigateToDossier(sourceObjectType: string, sourceGguid: string, intent?: string): INavigationWithDossierBuilder;
		/**
		 * Triggers a back navigation
		 */
		navigateBack(): void;
		/**
		 * Triggers a home navigation
		 */
		navigateHome(): void;
		/**
		 * A flag which indicates whether the api method [[reload]] is supported
		 */
		reloadSupported?: boolean;
		/**
		 * Reloads the current page(s) in the host application
		 */
		reload(): void;
		/**
		 * Signals a change in the state of the embedded app.
		 * This url is going to be used when restoring the app's state.
		 */
		urlChanged(url: string): void;
		/**
		 * List of possible navigation intents
		 */
		readonly intents: string[];
	}
	/**
	 * Entry point for triggering search functionalities
	 */
	interface ISearch {
		/**
		 * A flag which indicates whether the api method [[openSearch]] is supported
		 */
		readonly openSearchSupported: boolean;
		/**
		 * Opens a native search dialog and returns with the selected record's gguid.
		 * In case when the user cancels the operation, null value is returned.
		 * Returns a rejected promise in case when the api method is not supported.
		 */
		openSearch(objectType: string, query?: SearchQuery): Promise<OpenSearchResponse>;
	}
	interface ISettings {
		/**
		 * A flag which indicates whether accessing the app settings is supported
		 */
		readonly appSettingsSupported: boolean;
		/**
		 * Returns the app settings for the given scope and app.
		 *
		 * Without parameters, it returns the effective settings for the current user and app.
		 *
		 * Reading the effective settings returns all the properties that affects the current user,
		 * including the global properties and the schema defaults as fallback
		 *
		 * Writing the effective settings will set the properties of the current user.
		 *
		 * @param scope The scope of the returned settings. EFFECTIVE by default.
		 * @param appId The id of the app which the settings belongs to. The current app if absent.
		 */
		getAppSettings?<T extends Record<string, unknown> = any>(scope?: AppSettingsScope, appId?: string): AppSettings<T>;
	}
	interface IDialogApi {
		/**
		 * A flag which indicates whether opening a dialog is supported
		 */
		readonly openSupported: boolean;
		/**
		 * Opens a simple alert dialog with the given title and message.
		 */
		alert(title: string, message: string, style?: DialogStyle): Promise<IDialogResult>;
		/**
		 * Opens a simple confirmation dialog with the given title, message, a "Yes" and a "No" button.
		 *
		 * If "Yes" was pressed, the result's wasConfirmed() method returns true.
		 */
		confirm(title: string, message: string, style?: DialogStyle): Promise<IDialogResult>;
		/**
		 * Opens a dialog with the options given in the first argument.
		 */
		open(options: IDialogOptions): Promise<IDialogResult>;
	}
	/**
	 * Entry point for accessing context items
	 */
	interface IState<T extends ICustomState> {
		/**
		 * A flag which indicates whether the state change part of the api is supported.
		 */
		readonly onChangeSupported: boolean;
		/**
		 * Provides a hook for initial and subsequent state change handling.
		 */
		onChange(callback: (newState: T & BasicState, initialStateChange: boolean) => void): IDisposable | undefined;
		/**
		 * A flag which indicates whether the state update part of the api is supported.
		 */
		readonly updateSupported: boolean;
		/**
		 * Updates the state on the host side based on the changes made in the client.
		 * This must be invoked after e.g. a field value has been changed.
		 */
		update(): Promise<T & BasicState>;
		/**
		 * Provides access to the latest state instance.
		 */
		readonly current: T & BasicState;
	}
	/**
	 * Entry point for registering listener to the activation event.
	 */
	interface IActivationService {
		/**
		 * Register a listener which is notified, when the enable state of
		 * the web app widget is changed.
		 * @param {(ActivationMessage) => void} actor
		 * @returns {IDisposable}
		 * @memberof ActivationService
		 */
		registerListener(actor: (message: ActivationMessage) => void): IDisposable;
	}
	/**
	 * Provides access to context items
	 */
	interface IContext {
		/**
		 * A flag which indicates whether accessing the primary context item is suppoorted
		 */
		readonly primaryDataObjectAccessorSupported?: boolean;
		/**
		 * Returns a Promise which contains metadata for the primary data object or undefined if it's absent
		 */
		getPrimaryDataObject<T = any>(): Promise<IDataObjectContextItem<T> | undefined>;
		/**
		 * A flag which indicates whether accessing the primary mass data context item is suppoorted
		 */
		readonly primaryMassDataAccessorSupported?: boolean;
		/**
		 * Returns a Promise which contains metadata for the primary mass data or undefined if it's absent
		 */
		getPrimaryMassData<T = any>(): Promise<IMassDataObjectContextItem<T> | undefined>;
	}
	/**
	 * Entry point for opening overlays
	 */
	interface IOverlay {
		/**
		 * A flag which indicates whether opening a flyout menu is supported
		 */
		readonly flyoutMenuSupported: boolean;
		/**
		 * A flag which indicates whether opening a radial menu is supported
		 */
		readonly radialMenuSupported: boolean;
		/**
		 * Opens a flyout menu in the host environment
		 *
		 * @param {IFlyoutMenuItem[]} items The menu items to show
		 * @param {Coordinate | Area} positionOrArea The position or area relative to the client window (e.g. { x: event.clientX, y: event.clientY } or element.getBoundingClientRect())
		 * @returns {(Promise<IFlyoutMenuItem | null>)} The selected menu item or null if the flyout menu was closed without selecting anything.
		 */
		openFlyoutMenu(items: IFlyoutMenuItem[], positionOrArea: Coordinate | Area): Promise<IFlyoutMenuItem | null>;
		/**
		 * Opens the radial menu in the host environment
		 * Please note that the maximum amount of items to be shown might be limited by the host environment.
		 *
		 * @param {IRadialMenuItem[]} items The radial menu items to show
		 * @param {RadialMenuOptions} radialMenuOptions Representation related options
		 * @param {Coordinate} position The position relative to the client window (e.g. event.clientX, event.clientY)
		 * @returns {(Promise<IRadialMenuItem | null>)} The selected menu item or null if the radial menu was closed without selecting anything.
		 */
		openRadialMenu(items: IRadialMenuItem[], radialMenuOptions: RadialMenuOptions, position: Coordinate): Promise<IRadialMenuItem | null>;
	}
	/**
	 * Entry point for commands
	 */
	interface ICommandService {
		readonly commandsSupported: boolean;
		readonly pointIds: {
			actionMenu: typeof ACTION_MENU_ID;
			viewMenu: typeof VIEW_MENU_ID;
		};
		/**
		 * Contributes a command
		 * @param command The command to be shown
		 */
		contributeCommand(command: ICommand): IDisposable;
		/**
		 * Contributes a group
		 * @param command The group to be shown
		 */
		contributeGroup(command: IGroup): IDisposable;
	}
	/**
	 * Entry point for accessing the main application-wise loading indicator
	 */
	interface ILoadingIndicator {
		/**
		 * Shows the main application-wise loading indicator.
		 *
		 * @param options Defines options that can modify behaviors like UI blocking or timeout.
		 */
		show(options?: LoadingIndicatorOptions): any;
		/**
		 * Hides the main application-wise loading indicator.
		 */
		hide(): any;
		/**
		 * Shows the main application-wise loading indicator until the given promise is pending.
		 *
		 * @param promise The promise that controls the loading indicator state.
		 */
		showDuring(promise: Promise<any>, options?: LoadingIndicatorOptions): any;
		/**
		 * A flag which indicates whether showing the loading indicator is supported.
		 */
		readonly showSupported: boolean;
		/**
		 * A flag which indicates whether user interaction blocking on the current app/widget is supported.
		 */
		readonly blockSupported: boolean;
		/**
		 * A flag which indicates whether user interaction blocking on the host is supported.
		 */
		readonly blockHostSupported: boolean;
	}
	/**
	 * Entry point for accessing platform specific input devices
	 */
	interface IInputDeviceService {
		devicesSupported: boolean;
		/**
		 * Returns an accessor for the requested device
		 * @param type The type of the requested device
		 */
		getDevice<T extends InputDeviceType>(type: T): Promise<IInputDevice & {
			type: T;
		}>;
	}
}
/**
 * Message when the enabled state of the app / widget is changed.
 */
export interface ActivationMessage {
	isActive: boolean;
}
export interface AppSettings<T extends Record<string, any> = any> {
	/**
	 * Returns all stored settings.
	 */
	getAll(): Promise<Partial<T>>;
	/**
	 * Stores all given settings. By default, properties that are not passed are not removed.
	 *
	 * @param values All properties that needs to be stored.
	 * @param mode The mode which will used to merge with existing settings. EXTEND by default.
	 */
	setAll(values: Partial<T>, mode?: AppSettingsSetMode): Promise<void>;
	/**
	 * Returns the value of the given property.
	 *
	 * @param propertyName The name of the property to return.
	 */
	get<PROPERTY extends StringKeyOf<T> = StringKeyOf<T>>(propertyName: PROPERTY): Promise<T[PROPERTY]>;
	/**
	 * Sets the value of the given property.
	 *
	 * @param propertyName The name of the property to set.
	 * @param value The new value to be stored for the given property.
	 */
	set<PROPERTY extends StringKeyOf<T> = StringKeyOf<T>>(propertyName: PROPERTY, value: T[PROPERTY]): Promise<void>;
	/**
	 * Removes the stored property value.
	 *
	 * @param propertyName The name of the property to delete.
	 */
	delete(propertyName: StringKeyOf<T>): Promise<void>;
}
/**
 * Represents an area within to the client window, can usually be retrieved by calling getBoundingClientRect()
 */
export interface Area {
	x: number;
	y: number;
	width: number;
	height: number;
}
export interface BasicState {
	editMode: boolean;
	readOnly: boolean;
	enabled: boolean;
}
/**
 * Represents a position relative to the client window, can usually be retrieved from standard event properties, e.g. event.clientX, event.clientY
 */
export interface Coordinate {
	x: number;
	y: number;
}
export interface FieldInfo extends FieldMetadata {
	/**
	 * Contains the description of a potential validation failure
	 */
	validationMessage: string;
	/**
	 * Contains the validation state set by the last value change
	 */
	validationState: "valid" | "warning" | "error";
}
export interface FieldMetadata {
	/**
	 * Contains the name of the object type for which this field belongs to
	 */
	readonly objectTypeName: string;
	/**
	 * Contains the name for this field
	 */
	readonly fieldName: string;
	/**
	 * Contains the label for this field
	 */
	readonly label: string;
	/**
	 * True if the current user has read access on this field.
	 */
	readonly readable: boolean;
	/**
	 * True if the user has the privilege to update values for this field.
	 */
	readonly updateable: boolean;
	/**
	 * True for mandatory fields.
	 */
	readonly mandatory: boolean;
	/**
	 * True for recommended fields.
	 */
	readonly recommended: boolean;
	/**
	 * True for hidden fields.
	 */
	readonly hidden: boolean;
	/**
	 * True for custom fields.
	 */
	readonly custom: boolean;
}
export interface FieldWithPossibleValue<T> extends FieldInfo {
	/**
	 * The list of possible values for the current field, if it provides any.
	 */
	possibleValues?: T[];
}
/**
 * Contains the aggregation result for a single group.
 */
export interface GroupResult<GROUP, VALUE> {
	/**
	 * The group value is `undefined` for the group of records without a value in the grouped column.
	 */
	readonly groupValue: GROUP | undefined;
	/**
	 * The aggregated value for this group.
	 */
	readonly aggregatedValue: VALUE;
}
/**
 * Represents the common properties of an aggregation
 */
export interface IAggregationBase {
	type: "Aggregation";
	/**
	 * A flag which indicates whether the aggregation is grouped
	 */
	grouped: boolean;
}
export interface IBarcodeScanner extends IInputDeviceBase {
	type: "BarcodeScanner";
	scan(): Promise<string>;
}
/**
 * Contains information about a single command
 */
export interface ICommand extends ICommandRepresentation {
	/**
	 * The callback to be executed
	 */
	callback: VoidFunction;
}
/**
 * Contains representation specific information about a single command
 */
export interface ICommandRepresentation {
	/**
	 * The id of the command
	 * @type {string}
	 */
	id: string;
	/**
	 * A flag which determines whether the command is enabled.
	 * @type {boolean}
	 */
	enabled: boolean;
	/**
	 * The qualified name of the icon to be shown.
	 * The icons are loaded from the icons folder (next to the app manifest).
	 * Platform icons can be used with the `platform:` qualifier e.g. `platform:new`;
	 *
	 * @type {string}
	 */
	icon: string;
	/**
	 * The label to be shown
	 * @type {string}
	 */
	label: string;
	/**
	 * Alternative label in case this command is contributed to a command group
	 * @type {string}
	 */
	inGroupLabel?: string;
	/**
	 * The id of the parent group
	 * @type {string}
	 */
	pointId?: string;
	/**
	 * The description to be used (as a tooltip)
	 * @type {string}
	 */
	description: string;
}
/**
 * Base class for all context items
 */
export interface IContextItemBase extends IInvalidatable {
	/**
	 * The type of the context item
	 */
	type: PropertyAssignmentType;
	/**
	 * The name of the context item as defined in the form definition
	 */
	name: string;
	/**
	 * The actual object referred by this context item could change over time, when such an event occurs, the listener registered via this method is invoked.
	 *
	 * @param {VoidFunction} listener The method to be invoked on invalidation
	 * @returns {IDisposable} The returned Disposable object can be used for unregistering the listener.
	 */
	onInvalidate(listener: VoidFunction): IDisposable;
}
export interface ICustomState {
	[name: string]: StateValueTypes | StateValueTypes[] | Field<any> | IContextItem | IAggregation;
}
/**
 * Represents a data object context item
 */
export interface IDataObjectContextItem<T = any> extends IContextItemBase, IDataObjectContextItemMetadata {
	type: "DataObject";
	/**
	 * Loads the field metadata for the related object type
	 */
	getMetadata?(): Promise<Record<StringKeyOf<T>, FieldMetadata>>;
	/**
	 * Binds field change events to the given callback. The listener is invoked with the current state after registration.
	 * @param {string} fieldName The name of the field for which change events are requested
	 * @param {(value: FieldValue) => void} listener The method to be called on field changes
	 * @returns {IDisposable} The returned Disposable object can be used for unregistering the listener.
	 */
	bindField?<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(fieldName: FIELD, listener: (value: Field<T[FIELD]>) => void): IDisposable;
	/**
	 * Retrieves the current state for the given field
	 */
	getField?<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(fieldName: FIELD): Promise<Field<T[FIELD]>>;
	/**
	 * Retrieves the current state for the given fields
	 */
	getFields?<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(...fields: FIELD[]): Promise<FieldsFor<Pick<T, FIELD>>>;
	/**
	 * Updates the given field
	 */
	updateField?<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(field: Field<T[FIELD]>): Promise<void>;
	/**
	 * Updates the given fields
	 */
	updateFields?(fields: Partial<FieldsFor<T>>): Promise<void>;
}
export interface IDataObjectContextItemMetadata {
	type: "DataObject";
	/**
	 * The data record type
	 */
	objectTypeName: string;
	/**
	 * The id of the data record
	 */
	id: string;
	/**
	 * The name of the context item as defined in the form definition
	 */
	name: string;
}
/**
 * Represents a dependent data objects context item
 */
export interface IDependentDataObjectsContextItem<T = any> extends IContextItemBase, IDependentDataObjectsContextItemMetadata {
	type: "DependentDataObjects";
	/**
	 * Loads the field metadata for the related object type
	 */
	getMetadata?(): Promise<Record<StringKeyOf<T>, FieldMetadata>>;
	/**
	 * Loads items using the given parameters
	 *
	 * @param {FIELD[]} fieldNames The list of requested fields to be returned
	 */
	load<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(fieldNames: FIELD[]): Promise<IMassDataResponse<Pick<T, FIELD>>>;
}
export interface IDependentDataObjectsContextItemMetadata {
	/**
	 * The type of the context item
	 */
	type: "DependentDataObjects";
	/**
	 * The data record type
	 */
	objectTypeName: string;
	/**
	 * The name of the context item as defined in the form definition
	 */
	name: string;
}
export interface IDialogButtonDefinition {
	/**
	 * The ID that is used to identify the pressed button when processing the result.
	 *
	 * Note that it's not displayed to the user (in case the caption is present).
	 */
	id: DialogButtonId;
	/**
	 * The caption that will be shown to the user on the UI.
	 *
	 * Note that for default buttons (buttons with ID "OK", "YES", "NO" or "CANCEL") this
	 * is automatically set with a translated value if absent.
	 */
	caption?: string;
	/**
	 * Indicates whether the button defines the primary action and should be visualized differenly.
	 */
	primary?: boolean;
}
export interface IDialogOptions {
	/**
	 * The title for the dialog window.
	 */
	title: string;
	/**
	 * The message that will be shown in the main area of the dialog window.
	 */
	message: string;
	/**
	 * The buttons that will be shown for user interaction.
	 *
	 * It can be a preset ("OK" | "OK_CANCEL" | "YES_NO" | "YES_NO_CANCEL") or a list of
	 * DialogButtonDefinition that allows custom buttons to be shown.
	 */
	buttons?: DialogButtonPreset | IDialogButtonDefinition[];
	/**
	 * Defines the style of the dialog that usually shows the user how severe the shown information is.
	 */
	style?: DialogStyle;
}
export interface IDialogResult {
	/**
	 * The ID of the button that was pressed.
	 */
	buttonId: DialogButtonId;
	/**
	 * Returns true if OK or YES was pressed
	 */
	wasConfirmed(): boolean;
}
export interface IDisposable {
	dispose(): void;
}
export interface IEndpoint {
	postMessage(message: any, targetOrigin: string, transfer?: any[]): void;
	addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
	removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
}
/**
 * Represents a field based aggregation
 */
export interface IFieldAggregation extends IUngroupedAggregation, IInvalidatable {
	/**
	 * The name of the property to which this field reference based aggregation is assigned to
	 */
	name: string;
	/**
	 * A flag which indicates whether the aggregation is field reference based
	 */
	fieldAggregation: true;
	/**
	 * Loads the field metadata
	 */
	getMetadata(): Promise<FieldMetadata>;
}
/**
 * Represents a group
 */
export interface IGroup extends ICommandRepresentation {
	group?: true;
}
/**
 * Represents an aggregation with grouping
 */
export interface IGroupedAggregation extends IAggregationBase {
	grouped: true;
	/**
	 * Retrieves the full aggregation result, i.e., one aggregated value for each group.
	 *
	 * The array provided by the returned promise consists of single group result entries.
	 * Each entry contains the group value and the aggregated value for this group.
	 */
	get<GROUP, VALUE>(): Promise<GroupResult<GROUP, VALUE>[]>;
}
/**
 * Represents an aggregation context item with grouping
 */
export interface IGroupedAggregationContextItem extends IAggregationContextItemBase, IGroupedAggregation {
	grouped: true;
}
export interface IInputDeviceBase {
	type: InputDeviceType;
}
export interface IInvalidatable {
	/**
	 * The actual object referred by this context item could change over time, when such an event occurs, the listener registered via this method is invoked.
	 *
	 * @param {VoidFunction} listener The method to be invoked on invalidation
	 * @returns {IDisposable} The returned Disposable object can be used for unregistering the listener.
	 */
	onInvalidate(listener: VoidFunction): IDisposable;
}
/**
 * Represents a mass data context item
 */
export interface IMassDataObjectContextItem<T = any> extends IContextItemBase, IMassDataObjectContextItemMetadata {
	type: "MassData";
	/**
	 * Loads the field metadata for the related object type
	 */
	getMetadata?(): Promise<Record<StringKeyOf<T>, FieldMetadata>>;
	/**
	 * Loads items using the given parameters
	 *
	 * @param {FIELD[]} fieldNames The list of requested fields to be returned
	 * @param {number} from The start index
	 * @param {number} pageSize The page size to be used
	 * @param {string} [where] An additional where clause to be applied
	 */
	load<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(fieldNames: FIELD[], from: number, pageSize: number, where?: string): Promise<IMassDataResponse<Pick<T, FIELD>>>;
	/**
	 * Determines the number of items in this mass data.
	 */
	count(): Promise<number>;
	/**
	 * Computes the sum over the given numeric field.
	 *
	 * If the mass data is empty, the returned `Promise` resolves to `undefined`.
	 * Returns a rejected Promise, if the provided field is not numeric or does not belong to this mass data type.
	 *
	 * @param field The field to compute the sum over
	 */
	sum<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(field: FIELD): Promise<number | string | undefined>;
	/**
	 * Determines the minimum value of the given numeric field.
	 *
	 * If the mass data is empty, the returned `Promise` resolves to `undefined`.
	 * Returns a rejected Promise, if the provided field is not numeric or does not belong to this mass data type.
	 *
	 * @param field The field to determine the minimum value for
	 */
	min<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(field: FIELD): Promise<number | string | undefined>;
	/**
	 * Determines the maximum value of the given numeric field.
	 *
	 * If the mass data is empty, the returned `Promise` resolves to `undefined`.
	 * Returns a rejected Promise, if the provided field is not numeric or does not belong to this mass data type.
	 *
	 * @param field The field to determine the maximum value for
	 */
	max<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(field: FIELD): Promise<number | string | undefined>;
	/**
	 * Computes the average value of the given numeric field.
	 *
	 * If the mass data is empty, the returned `Promise` resolves to `undefined`.
	 * Returns a rejected Promise, if the provided field is not numeric or does not belong to this mass data type.
	 *
	 * @param field The field to compute the average value for
	 */
	average<FIELD extends StringKeyOf<T> = StringKeyOf<T>>(field: FIELD): Promise<number | string | undefined>;
}
export interface IMassDataObjectContextItemMetadata {
	/**
	 * The type of the context item
	 */
	type: "MassData";
	/**
	 * The data record type
	 */
	objectTypeName: string;
	/**
	 * The name of the context item as defined in the form definition
	 */
	name: string;
}
/**
 * Contains the result of a mass data load request
 */
export interface IMassDataResponse<T> {
	/**
	 * The resulting rows
	 */
	rows: T[];
	/**
	 * Metadata for the requested columns
	 */
	columns: {
		[K in keyof T]: FieldMetadata;
	};
}
/**
 * Contains information about a single menu item
 */
export interface IMenuItem {
	/**
	 * The id of the menu item
	 * @type {string}
	 */
	id: string;
	/**
	 * A flag which determines whether the menu item is enabled.
	 * @type {boolean}
	 */
	enabled: boolean;
	/**
	 * The qualified name of the icon to be shown.
	 * The icons are loaded from the icons folder (next to the app manifest).
	 * Platform icons can be used with the `platform:` qualifier e.g. `platform:new`;
	 *
	 * @type {string}
	 */
	icon: string;
	/**
	 * The caption to be shown
	 * @type {string}
	 */
	caption: string;
	/**
	 * The description to be used (as a tooltip)
	 * @type {string}
	 */
	description: string;
}
/**
 * Represents a horizontal separator between list items
 */
export interface IMenuItemSeparator {
	separator: true;
}
export interface INFCReader extends IInputDeviceBase {
	type: "NFCReader";
	read(): Promise<INFCTag>;
}
export interface INFCRecord {
	readonly recordType: INFCRecordType;
	readonly absoluteUri: string;
	readonly mimeType: string;
	readonly payload: DataView;
}
export interface INFCTag {
	readonly serialNumber: string;
	readonly records: readonly INFCRecord[];
}
/**
 * Navigation builder for navigating without context.
 */
export interface INavigationBuilder {
	/**
	 * Trigger the navigation with the configured parameters.
	 * @return {Promise<void>}
	 */
	navigate(): Promise<void>;
	/**
	 * Set the navigation intent.
	 * @param {String} intentName
	 * @return {this}
	 */
	withIntent(intentName: string): this;
	/**
	 * Whether the new page(s) should be opened on a new tab or not. Note that opening on new tab is only supported for
	 * read mode navigations.
	 * @param {boolean} defaults to true
	 * @return {this}
	 */
	openOnNewTab(newTab?: boolean): this;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = void, TResult2 = never>(onfulfilled?: ((value: void) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<void | TResult>;
}
/**
 * Navigation builder for dossier navigation
 */
export interface INavigationWithDossierBuilder extends INavigationBuilder {
	/**
	 * Sets of the object type of the source item.
	 * @param {String} sourceObjectType
	 * @return {this}
	 */
	withSourceObjectType(sourceObjectType: string): this;
	/**
	 * Sets the gguid of the source item.
	 * @param {String} sourceGguid
	 * @return {this}
	 */
	withSourceGguid(sourceGguid: string): this;
	/**
	 * Sets of the object type of the selected item.
	 * @param {String} selectedObjectType
	 * @return {this}
	 */
	withSelectedObjectType(selectedObjectType: string): this;
	/**
	 * Sets the selected data object guid, that should be member of the dossier items
	 * @param {String} selectedGguid
	 * @return {this}
	 */
	withSelectedGguid(selectedGguid: string): this;
	/**
	 * Sets the typesToShow list, which defines the available object types.
	 * If it is empty the server configuration is used.
	 * @param {String[]} typesToShow
	 * @return {this}
	 */
	withTypeToShow(typesToShow: string[]): this;
}
/**
 * Navigation builder for navigating with data obejct.
 */
export interface INavigationWithRecordBuilder extends INavigationBuilder {
	/**
	 * Sets the type of the data object.
	 * @param {String} objectType
	 * @return {this}
	 */
	withObjectType(objectType: string): this;
	/**
	 * Sets the id (gguid) of the data object
	 * @param {String} gguid
	 * @return {this}
	 */
	withGguid(gguid: string): this;
	/**
	 * Indicates that the navigation should open the edit mode.
	 * @return {this}
	 */
	openEditMode(): this;
}
/**
 * Navigation builder for navigating with a list of data obejcts.
 */
export interface INavigationWithRecordsBuilder extends INavigationBuilder {
	/**
	 * Sets the type of the data objects.
	 * @param {String} objectType
	 * @return {this}
	 */
	withObjectType(objectType: string): this;
	/**
	 * Sets the id (gguid) of the selected data object. Selected id should be
	 * presented in the gguids list, see {@link withGguid}.
	 * @param {String} selectedGguid
	 * @return {this}
	 */
	withSelectedGguid(selectedGguid: string): this;
	/**
	 * Sets the list of the data objects ids.
	 * @param {string[]} gguids
	 * @return {this}
	 */
	withGguids(gguids: string[]): this;
}
/**
 * Contains information about a single radial menu item
 */
export interface IRadialMenuItem extends IMenuItem {
	/**
	 * The category to be used for the slice
	 */
	category: RadialMenuCategory;
}
/**
 * Represents a scripted aggregation
 */
export interface IScriptedAggregation extends IInvalidatable {
	type: "ScriptedAggregation";
	/**
	 * The name of the property to which this script based aggregation is assigned to
	 */
	name: string;
	/**
	 * A flag which indicates whether the aggregation is script based
	 */
	scriptedAggregation: true;
	/**
	 * Retrieves the aggregation result for this aggregation.
	 *
	 */
	get(): Promise<ScriptedUngroupedAggregationResult<ScriptedAggregationRawValueTypes> | ScriptedGroupedAggregationResult<ScriptedAggregationRawValueTypes>>;
}
/**
 * Represents an aggregation without grouping
 */
export interface IUngroupedAggregation extends IAggregationBase {
	grouped: false;
	/**
	 * Retrieves the single aggregated value from this aggregation.
	 *
	 * The returned Promise resolves to `undefined` if the source mass data is empty
	 * and an aggregation function other than COUNT is used.
	 */
	get<VALUE>(): Promise<VALUE | undefined>;
}
/**
 * Represents an aggregation context item without grouping
 */
export interface IUngroupedAggregationContextItem extends IAggregationContextItemBase, IUngroupedAggregation {
	grouped: false;
}
export interface LoadingIndicatorOptions {
	/**
	 * The time in milliseconds after the loading indicator will be stopped automatically.
	 * The default timeout is 30 seconds, the longest is 1 minute.
	 */
	timeoutInMs?: number;
	/**
	 * Indicates whether user interactions on the host should be blocked while the
	 * loading indicator is on.
	 */
	blockHost?: boolean;
	/**
	 * Indicates whether user interactions on the current app/widget should be blocked while the
	 * loading indicator is on.
	 *
	 * Note that although some interaction may be blocked, this should not be considered as a
	 * security feature, additional steps may be needed for example to disable keyboard actions.
	 */
	block?: boolean;
}
export interface LocaleInformation {
	/**
	 * ISO code of the user locale
	 */
	language: string;
}
export interface MultiValueField<T> extends FieldWithPossibleValue<T> {
	/**
	 * Current value of the field
	 */
	value: T[];
}
/**
 * Contains information about the search selection result
 */
export interface OpenSearchResponse {
	/**
	 * Array of gguids of the selected objects
	 */
	objectGguids: string[];
}
/**
 * Contains representation related options for the radial menu
 */
export interface RadialMenuOptions {
	centerIcon: string;
	centerColor: string;
}
/**
 * Configuration class for the search queries
 */
export interface SearchQuery {
	/**
	 * Where clause for the query, e.g. `WORKINGPERCENT > 0 AND PRIORITY = 'A'`
	 */
	where?: string;
	/**
	 * A flag which indicates whether the search results should be shown without a search text
	 */
	showResultsWithEmptySearchTerm?: boolean;
	/**
	 * Order by clause for the query, e.g. `KEYWORD ASC, UPDATETIMESTAMP DESC`
	 */
	orderBy?: string;
}
export interface SelectionValue {
	label: string;
	id: string;
}
export interface SingleValueField<T> extends FieldWithPossibleValue<T> {
	/**
	 * Current value of the field
	 */
	value: T;
}
export interface StringTreeSuggestField extends FieldInfo {
	/**
	 * Current value of the field
	 */
	value: StringTreeSuggestPath[];
	/**
	 * Root node of the tree of possible values
	 */
	root: StringTreeSuggestNode;
}
export interface StringTreeSuggestNode {
	name: string;
	path: StringTreeSuggestPath;
	selectable: boolean;
	selectionType: SelectionType;
	childSelectionType: SelectionType;
	children: StringTreeSuggestNode[];
}
export type AppSettingsScope = "GLOBAL" | "USER" | "EFFECTIVE";
export type AppSettingsSetMode = "OVERWRITE" | "EXTEND";
/**
 * The back navigation mode determines how the navigation stack is threated.
 *
 * NONE
 * The host can navigate back without navigating back inside
 * the web app. This is the default.
 *
 * LINEAR
 * The visited urls are stored in a stack, upon back navigation in the host,
 * the web app url is restored to the previous value.
 *
 * COMPRESSED
 * Similar to the LINEAR mode, with the exception that if a url is visited
 * again, the navigation history of the web app is dropped until that point.
 */
export type BackNavigationMode = "NONE" | "LINEAR" | "COMPRESSED";
/**
 * The type of the context item
 * @deprecated for correctness in favor of {@link PropertyAssignmentType}
 */
export type ContextItemTypes = PropertyAssignmentType;
export type DialogButtonId = "OK" | "YES" | "NO" | "CANCEL" | (string & {
	x?: never;
});
export type DialogButtonPreset = "OK" | "OK_CANCEL" | "YES_NO" | "YES_NO_CANCEL";
export type DialogStyle = "INFO" | "WARNING" | "ERROR";
export type Field<T> = SingleValueField<T> | MultiValueField<T> | StringTreeSuggestField;
export type FieldsFor<T> = {
	[P in keyof T]: Field<T[P]>;
};
/**
 * Represents an aggregation property assignment
 */
export type IAggregation = IGroupedAggregation | IUngroupedAggregation | IScriptedAggregation | IFieldAggregation;
/**
 * Represents an aggregation context item
 */
export type IAggregationContextItem = IUngroupedAggregationContextItem | IGroupedAggregationContextItem;
/**
 * Represents the common properties of an aggregation context item
 */
export type IAggregationContextItemBase = IContextItemBase & IAggregationBase;
/**
 * Represents a context item from the current form
 */
export type IContextItem = IDataObjectContextItem | IMassDataObjectContextItem | IDependentDataObjectsContextItem | IAggregationContextItem;
/**
 * Contains information about a single flyout menu item
 */
export type IFlyoutMenuItem = IMenuItem | IMenuItemSeparator;
export type IInputDevice = IBarcodeScanner | INFCReader;
export type INFCRecordType = "Empty" | "WellKnown" | "Mime" | "AbsoluteUrl" | "External" | "Unknown" | "Unchanged";
export type IPromise<T> = Promise<T>;
export type InputDeviceType = "BarcodeScanner" | "NFCReader";
/**
 * The type of the property
 */
export type PropertyAssignmentType = "DataObject" | "MassData" | "DependentDataObjects" | "Aggregation" | "ScriptedAggregation";
/**
 * The category a radial menu item belongs to
 */
export type RadialMenuCategory = "standard" | "communication" | "creation" | "information";
/**
 * Represents a single value within an aggregation.
 */
export type ScriptedAggregatedValue<RAW_VALUE extends ScriptedAggregationRawValueTypes> = {
	/**
	 * Raw value of the aggregation result.
	 */
	raw?: RAW_VALUE;
	/**
	 * Numeric value, e.g., used for drawing charts.
	 */
	numeric?: number | string;
	/**
	 * Display value, e.g., for the label of bars, tooltips, ...
	 * If not specified, the widget is free to generate the display value
	 * from the raw/numeric value and formatting options.
	 */
	display?: string;
};
export type ScriptedAggregationRawValueTypes = number | string | boolean | Date | undefined;
/**
 * Represents the formatting options for a given aggregation result.
 */
export type ScriptedFormattingOptions = {
	/**
	 * The number of decimal places to display for numeric values.
	 */
	decimalPlaces?: number;
	/**
	 * Additional formatting options for date values
	 */
	dateFormat?: Partial<{
		/**
		 * Include the date portion (year, month, day) in the output.
		 *
		 * Default: true
		 */
		date: boolean;
		/**
		 * Include the time portion (hours, minutes, and optionally seconds) in the output.
		 *
		 * Default: true
		 */
		time: boolean;
		/**
		 * If time is included, seconds will be displayed in the output as well.
		 *
		 * Default: false
		 */
		seconds: boolean;
		/**
		 * If the date is yesterday, today, or tomorrow, the date will be formatted textually
		 * as "Yesterday", "Today", or "Tomorrow", in the respective user language.
		 *
		 * Default: true
		 */
		preferRelativeDay: boolean;
	}>;
	/**
	 * The unit of the aggregated value.
	 */
	unit?: string;
};
/**
 * Represents a single group within a grouped aggregation result.
 */
export type ScriptedGroupResult<RAW_VALUE extends ScriptedAggregationRawValueTypes> = {
	/**
	 * Label of the group to be displayed.
	 */
	group?: string;
	/**
	 * Group value
	 */
	value: ScriptedAggregatedValue<RAW_VALUE>;
	/**
	 * Group color
	 */
	color?: string;
};
/**
 * Represents a grouped aggregation result.
 */
export type ScriptedGroupedAggregationResult<RAW_VALUE extends ScriptedAggregationRawValueTypes> = {
	type: "grouped";
	groups: ScriptedGroupResult<RAW_VALUE>[];
	formatting?: ScriptedFormattingOptions;
};
/**
 * Represents an ungrouped aggregation result.
 */
export type ScriptedUngroupedAggregationResult<RAW_VALUE extends ScriptedAggregationRawValueTypes> = {
	type: "ungrouped";
	value: ScriptedAggregatedValue<RAW_VALUE>;
	formatting?: ScriptedFormattingOptions;
};
export type SelectionType = "single" | "multi";
export type StateValueTypes = FieldMetadata | boolean | number | string;
export type StringKeyOf<T> = Extract<keyof T, string>;
export type StringTreeSuggestPath = string[];

export as namespace smartdesign;

export {};
